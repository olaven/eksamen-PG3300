@startuml Class diagram 



namespace item {
    interface Item {
        + <<Property>> Name : String 
        + <<Property>> Owner : Person 
        ~ getPrice() : float
        ~ getCondition() : String
        ~ getDamage() : String
        ~ getModification() : String
        ~ getInformation() : String 
    }

    Item o-- "1" FleaMarket.Person 

    class ConcreteItem implements Item {
        / Name : String 
    }


    abstract ItemDecorator implements Item {
        - item : Item
        # random : Random
    }

    ItemDecorator "1" o-- Item 


    class PerfectConditionItemDecorator extends ItemDecorator
    class NoDamageItemDecorator extends ItemDecorator
    class WithWingsModificationItemDecorator extends ItemDecorator

    note "More in implementation" as MoreInImplementation
    MoreInImplementation .. ItemDecorator


    enum Decoration {
        NoDamage,
        PerfectCondition,
        WithWings, 
    }

    ItemFactory -- Decoration : uses 

    class ItemFactory {
        + getNew : Item  
        
    }

    ItemFactory -- Item : creates 
}

namespace FleaMarket {
    

    class Wallet {
        + <<Property>> Balance : float 
        + Wallet ()
    }

    abstract Person {
        + act : void 
        + <<Property>> Name : String 
        + <<Property>> Image : String 
        # Wallet : Wallet 
        # Items : List<Item> 
                    
        # Person(name : string)
    }

    Wallet "1" *-- Person
    Person -- Market : trades 


    class Customer extends Person {
        / act : void 
    }

    class Salesman extends Person {
        / act void 
    }
    
    class PersonFactory {
        - {static} ArrayList : Names
        - {static} Random : Random
        + {static} GetPerson(type PersonType) : Person
        - {static} GetRandomName() : string
    }
    
    PersonFactory -- Simulation
    
    PersonFactory -- Person

    class PersonImage {
        + <<Property>> string : Image
    }

    class PersonImagePointer {
        + <<Property>> {static} PersonImage : PersonImage 
    }

    note top of PersonImagePointer : minimal Flyweight-pattern implementation

    PersonImagePointer o-- PersonImage
    Person *-- PersonImagePointer

    note "Singleton" as singleton
    class Market {
        
        - _market : Market
        - _items : List<IItem>
        + EvenHappening : EventHandler
        - {static} _staticLock : object
        - Padlock : object
        + <<Property>> Instance : Market  
        + addForSale(item : Item) : void  
        + sellItem(item : Item) : void 
        + Market()
    }

    Market .. singleton


    class Program { 
        + main() : void
    }

    class Simulation {
        - _random : Random
        - _saleCount : int
        - _customers : List<Customer> 
        - _salesmen : List<Salesman> 
        ~ run() : void 
        - Simulation(saleCount : int)
        - GetRandomSellers(): Salesman
        - GiveItemsTo(persons : IEnumerable<Person>): void
        - PopulateSalesmen() List<Salesman>
        - PopulateCustomers() List<Customer>
        - PopulatePersons() List<Person>
        
        
    }

    Program -- "1" Simulation : starts
    Simulation o-- "*" Market

    Salesman -- item.ItemFactory : gets something to sell 

}


@enduml